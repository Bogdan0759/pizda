ChainFS (CFS) — Спецификация v1.0
Основные характеристики
Размер блока: 512 байт (равен стандартному сектору диска, чтобы не мучиться с буферами).
Имя файла: 32 байта (фиксировано).
Макс. размер диска: 2 Терабайта (при 32-битной адресации).
Структура: Плоская (все файлы в корне /).
Порядок байт: Little-Endian.
1. Карта Диска (Disk Layout)
Диск разбит на 4 четкие зоны. Все адреса — это номера блоков (LBA), начиная с 0.
Зона	Старт (Блок)	Размер (Блоков)	Описание
Superblock	0	1	Информация о системе.
File Table	1	M	Таблица описания файлов (кто, где, сколько весит).
Block Map	1 + M	N	Карта цепочек (какой блок идет следующим).
Data Area	1 + M + N	Всё остальное	Сами данные файлов.
Примечание: M (размер таблицы файлов) и N (размер карты блоков) вычисляются при форматировании и записываются в суперблок.
2. Структуры данных
2.1. Superblock (Блок 0)
Всего 512 байт. Лежит в самом начале диска.
Смещение	Тип	Имя	Описание
0x00	u32	Magic	0xCAFEBABE (Магическое число).
0x04	u32	BlockCount	Всего блоков на диске.
0x08	u32	FileTableBlockCount	Размер зоны "File Table" в блоках (M).
0x0C	u32	BlockMapBlockCount	Размер зоны "Block Map" в блоках (N).
0x10	u32	TotalFiles	Максимальное число файлов (лимит).
0x14	u8[492]	Padding	Нули.
2.2. File Entry (Запись о файле)
Зона File Table — это просто массив вот таких структур.
Размер одной записи: 64 байта.
В один блок (512 байт) влезает ровно 8 записей.
Смещение	Тип	Имя	Описание
0x00	u8	Status	0 = Свободно, 1 = Файл существует.
0x01	char[31]	Name	Имя файла (ASCII, завершается нулем).
0x20	u32	Size	Размер файла в байтах.
0x24	u32	StartBlock	Индекс первого блока данных в зоне Data Area.
0x28	u8[24]	Reserved	Зарезервировано (забито нулями).
2.3. The Block Map (Карта Цепочек)
Это самое важное упрощение. Вместо битовых карт мы используем массив чисел u32.
Каждый элемент массива соответствует блоку в зоне Data Area.
Значение элемента говорит нам, что делать дальше.
Значения в Block Map:
0x00000000: Блок свободен (Free).
0xFFFFFFFF: Конец файла (EOF).
Любое другое число: Индекс следующего блока этого файла.
Пример:
Если файл занимает блоки 5, 6 и 9:
Entry[5] будет равно 6.
Entry[6] будет равно 9.
Entry[9] будет равно 0xFFFFFFFF (Конец).
3. Алгоритмы (Как это кодить)
Вот тебе готовая логика драйвера. Никакой магии, только индексы массивов.
3.1. Как прочитать файл "game.exe"
Загрузи Суперблок (Блок 0). Узнай, где начинается File Table (всегда блок 1) и какой у нее размер.
Поиск файла:
Читай блоки зоны File Table по очереди.
В каждом блоке перебирай 8 структур File Entry.
Если Status == 1 и Name == "game.exe", бинго!
Запомни StartBlock (допустим, это 100) и Size.
Чтение данных:
Вычисли реальный адрес блока на диске.
Формула: RealLBA = (1 + M + N) + StartBlock.
(1 + M + N) — это начало зоны данных (DataStart).
Прочитай блок RealLBA в буфер.
Если прочитано меньше, чем Size, нужно искать продолжение.
Поиск следующего куска:
Нужно узнать, какой блок идет после 100.
Идем в зону Block Map. Эта зона начинается с блока 1 + M.
Нам нужно 100-е число (u32) в этом массиве.
В одном секторе помещается 128 чисел u32 (512 / 4).
Значит, нам нужен сектор Block Map с индексом 100 / 128.
Смещение внутри сектора: (100 % 128) * 4.
Читаем значение. Допустим, там число 105.
Значит, следующий блок данных — 105. Повторяем пункт 3 для блока 105.
Если встретили 0xFFFFFFFF — стоп.
3.2. Как создать файл (Запись)
Найти свободное место в таблице файлов:
Пробегаем File Table. Ищем запись, где Status == 0.
Нашли? Пишем туда Status = 1, Name = "myfile.txt", Size = 0.
Выделить первый блок:
Пробегаем зону Block Map. Ищем число 0 (свободно).
Допустим, нашли свободный индекс 55.
Записываем в File Entry -> StartBlock = 55.
Сразу же в Block Map по индексу 55 пишем 0xFFFFFFFF (пока что это конец файла).
Сохраняем измененные сектора на диск.
Запись данных:
Пишем данные в сектор DataStart + 55.
Если данных больше чем 512 байт:
Снова ищем свободный индекс в Block Map (допустим, нашли 56).
В Block Map по индексу 55 пишем 56 (создаем связь).
В Block Map по индексу 56 пишем 0xFFFFFFFF (новый конец).
Пишем данные в сектор DataStart + 56.
Обновляем Size в File Entry.
3.3. Как удалить файл
Находим файл в File Table.
Берем его StartBlock (пусть 55).
Идем в Block Map. Читаем значение по индексу 55.
Запоминаем значение (например, 56).
Пишем в индекс 55 число 0 (свободен).
Переходим к индексу 56. Повторяем цепочку, пока не дойдем до 0xFFFFFFFF.
Идем в File Table и ставим у файла Status = 0. Всё.
4. Пример "на пальцах"
Представь диск всего на 10 блоков (очень маленький). Блок = 10 байт (для простоты).
Блок 0 (Суперблок): FileTableSize=1, BlockMapSize=1.
Блок 1 (File Table):
Запись 0: Name="A.txt", Start=0
Запись 1: Name="B.txt", Start=2
Блок 2 (Block Map): (Массив чисел)
[1, EOF, 3, EOF, 0, 0 ...]
Индекс 0 (принадлежит A.txt): значение 1.
Индекс 1 (след. кусок A.txt): значение EOF (Конец).
Индекс 2 (принадлежит B.txt): значение 3.
Индекс 3 (след. кусок B.txt): значение EOF.
Индексы 4, 5...: 0 (Свободны).
Блок 3 (Data Area Start):
(Физический Блок 3) Данные A.txt (часть 1)
(Физический Блок 4) Данные A.txt (часть 2)
(Физический Блок 5) Данные B.txt (часть 1)
(Физический Блок 6) Данные B.txt (часть 2)